# Lection 8


## Введение в БД


### Расширенные возможности SQL.
---------------------

### Представления

Бывает ситуации, в которых нам необходимо работать с данными базы, уже приведенными к какому-то виду. Например, нам нужно подготовить данные для расписания, где у нас уже будут Фамилии преподавателей, номера групп, название предметов, вместо ID. А уже после подготовки, мы на эту выборку-проекцию будем делать запросы. Как мы говорили, SELECT-запрос создает таблицу. А что, если нам эту таблицу неким образом запомнить?
Собственно эту функцию и выполняет представление.

Создать представление можно следующим образом:
> CREATE VIEW viewName AS someSelectQuery;

То есть мы даем представлению имя. Учтите, одноименных таблиц в БД быть не должно.
 И в блоке AS пишем любой SELECT-запрос.
И после этого мы можем использовать наше представление, как обычную таблицу:
> SELECT * FROM viewName;

Собственно, поэтому представления и таблицы имеют общее пространство имен. Более того, по запросу вы не сможете понять, является ли это таблицей, либо представлением.
По-факту, происходит подстановка и выполняется вложенный запрос. При этом существуют различные типы представлений, в частности, в PostgreSQL есть такие (materialized view), которые существуют на самом деле.

Удаление:
> DROP VIEW viewName;

Создавая представление, появляется просто запись о том, что данному VIEW соответствует такой-то запрос SELECT.
Важное отличие VIEW от таблиц в том, что не все представления могут быть модифицированы. Модифицируемое представление
определяется следующими критериями:

* основывается только на одной базовой таблице;

* содержит первичный ключ этой таблицы;

* не содержит DISTINCT в своем определении;
* не использует GROUP BY или HAVING в своем определении;

* по возможности не применяет в своем определении подзапросы;

* не использует константы или выражения значений среди выбранных полей вывода;

* в просмотр должен быть включен каждый столбец таблицы, имеющий атрибут NOT NULL;

* оператор SELECT просмотра не использует агрегирующие (итоговые) функции, соединения таблиц, хранимые процедуры и функции, определенные пользователем;

* основывается на одиночном запросе, поэтому объединение UNION не разрешено.
